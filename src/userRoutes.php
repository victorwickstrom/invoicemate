<?php

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Slim\App;
use Psr\Container\ContainerInterface;
use App\AuthService;

/**
 * User management routes.
 *
 * This file defines endpoints for managing users and authenticating
 * against the system.  Administrators can create new users within
 * their organisation, update existing users and all users may authenticate
 * via the login endpoint to receive a JSON Web Token.  Credentials are
 * securely hashed using PHP's password_hash() and tokens are generated by
 * AuthService.
 */
return function (App $app) {
    /** @var ContainerInterface $container */
    $container = $app->getContainer();

    /**
     * Create a new user for an organisation.
     *
     * POST /v1/{organizationId}/users
     *
     * The first user for an organisation may be created without authentication.
     * Subsequent creations require the caller to be an admin.  Usernames are
     * scoped per organisation to allow the same username to exist in different
     * organisations.  Passwords must be at least 8 characters long and contain
     * both letters and numbers.
     *
     * @param Request  $request  PSR-7 request containing a JSON body with
     *     `username` (string), `password` (string) and optional `role`
     *     ("admin", "user" or "accountant").  Missing or invalid values will
     *     result in a 400 response.
     * @param Response $response PSR-7 response used to return JSON data to the client.
     * @param array    $args     Route parameters with at least `organizationId`
     *     (integer) identifying the organisation to which the user should be added.
     *
     * @return Response Returns a JSON response containing the new user's
     *     `id`, `username` and `role` on success.  HTTP 201 is returned on
     *     success; HTTP 400 on invalid input; HTTP 403 if the caller lacks
     *     admin privileges when additional users exist.
     *
     * @throws \PDOException If a database error occurs while inserting the
     *     user or writing audit log entries.
     *
     * @api
     * @since 1.0.0
     *
     * @example
     * ```json
     * {
     *   "username": "jdoe",
     *   "password": "Pa55word123",
     *   "role": "admin"
     * }
     * ```
     */
    $app->post('/v1/{organizationId}/users', function (Request $request, Response $response, array $args) use ($container) {
        /** @var \PDO $pdo */
        $pdo = $container->get('db');
        /** @var AuthService $auth */
        $auth = $container->get(AuthService::class);
        $orgId = (int) $args['organizationId'];
        $data = json_decode($request->getBody()->getContents(), true);
        $username = trim($data['username'] ?? '');
        $password = $data['password'] ?? '';
        $role     = $data['role'] ?? 'user';
        // Basic input validation
        if ($username === '' || $password === '' || !in_array($role, ['admin','user','accountant'], true)) {
            $response->getBody()->write(json_encode(['error' => 'Invalid input: username, password and valid role are required']));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Enforce minimal password complexity: at least 8 chars with letters and numbers
        if (strlen($password) < 8 || !preg_match('/[A-Za-z]/', $password) || !preg_match('/\d/', $password)) {
            $response->getBody()->write(json_encode(['error' => 'Password must be at least 8 characters long and contain both letters and numbers']));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Check if any users exist for the organisation
        $stmtCheck = $pdo->prepare('SELECT COUNT(*) FROM users WHERE organization_id = :org');
        $stmtCheck->execute([':org' => $orgId]);
        $userCount = (int) $stmtCheck->fetchColumn();
        // Require current user to be admin if at least one user exists
        $requestUser = $request->getAttribute('user');
        if ($userCount > 0) {
            $roles = $requestUser['roles'] ?? [];
            if (!in_array('admin', $roles, true)) {
                $response->getBody()->write(json_encode(['error' => 'Forbidden: only admin may create additional users']));
                return $response->withStatus(403)->withHeader('Content-Type', 'application/json');
            }
        }
        // Check if username already exists within the organisation
        $stmtExists = $pdo->prepare('SELECT COUNT(*) FROM users WHERE username = :username AND organization_id = :org');
        $stmtExists->execute([':username' => $username, ':org' => $orgId]);
        if ((int) $stmtExists->fetchColumn() > 0) {
            $response->getBody()->write(json_encode(['error' => 'Username already exists for this organisation']));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Hash password and insert
        $passwordHash = $auth->hashPassword($password);
        $stmtInsert = $pdo->prepare('INSERT INTO users (organization_id, username, password_hash, role, created_at, updated_at) VALUES (:org, :username, :hash, :role, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)');
        $stmtInsert->execute([
            ':org'      => $orgId,
            ':username' => $username,
            ':hash'     => $passwordHash,
            ':role'     => $role
        ]);
        $newId = (int) $pdo->lastInsertId();
        // Log creation in audit_log table
        $userPayload = $request->getAttribute('user');
        $userId = $userPayload['user_id'] ?? null;
        $logStmt = $pdo->prepare('INSERT INTO audit_log (organization_id, user_id, table_name, record_id, operation, changed_data) VALUES (:org, :userId, :tableName, :recordId, :operation, :changedData)');
        $logStmt->execute([
            ':org'        => $orgId,
            ':userId'     => $userId,
            ':tableName'  => 'users',
            ':recordId'   => $newId,
            ':operation'  => 'INSERT',
            ':changedData'=> json_encode(['username' => $username, 'role' => $role])
        ]);
        $response->getBody()->write(json_encode(['id' => $newId, 'username' => $username, 'role' => $role]));
        return $response->withStatus(201)->withHeader('Content-Type', 'application/json');
    });

    /**
     * Update an existing user.
     *
     * PUT /v1/{organizationId}/users/{id}
     *
     * Only administrators may update users.  The organisation of the user
     * being updated must match the organisation in the URL to prevent
     * cross‑org modification.  The request body may include a new role
     * and/or a new password.  Password changes trigger a re‑hash; roles
     * are validated against the allowed values `admin`, `user` and
     * `accountant`.  If both fields are omitted no update will occur.
     *
     * @param Request  $request  PSR-7 request containing a JSON body with
     *     optional `role` (string) and `password` (string).  Both fields
     *     are validated for correctness; invalid values cause a 400 response.
     * @param Response $response Response object used to write JSON
     *     responses.
     * @param array    $args     Route parameters including `organizationId`
     *     (integer) and `id` (integer) identifying the user to update.
     *
     * @return Response A JSON response with a message on success.
     *     Returns HTTP 200 with `{ "message": "User updated successfully" }` on
     *     success, HTTP 400 for invalid input or no updatable fields,
     *     HTTP 403 if the caller is not an admin, and HTTP 404 if the user
     *     does not exist in the given organisation.
     *
     * @throws \PDOException If a database error occurs during the update
     *     or audit logging.
     *
     * @api
     * @since 1.0.0
     *
     * @example
     * ```json
     * {
     *   "role": "accountant",
     *   "password": "NewPa55word"
     * }
     * ```
     */
    $app->put('/v1/{organizationId}/users/{id}', function (Request $request, Response $response, array $args) use ($container) {
        /** @var \PDO $pdo */
        $pdo = $container->get('db');
        /** @var AuthService $auth */
        $auth = $container->get(AuthService::class);
        $orgId = (int) $args['organizationId'];
        $userIdToUpdate = (int) $args['id'];
        // Require admin role
        $requestUser = $request->getAttribute('user');
        $roles = $requestUser['roles'] ?? [];
        if (!in_array('admin', $roles, true)) {
            $response->getBody()->write(json_encode(['error' => 'Forbidden: only admin may update users']));
            return $response->withStatus(403)->withHeader('Content-Type', 'application/json');
        }
        // Fetch the existing user to ensure it belongs to the same organisation
        $stmtSelect = $pdo->prepare('SELECT organization_id, role FROM users WHERE id = :id');
        $stmtSelect->execute([':id' => $userIdToUpdate]);
        $existing = $stmtSelect->fetch(PDO::FETCH_ASSOC);
        if (!$existing || (int)$existing['organization_id'] !== $orgId) {
            $response->getBody()->write(json_encode(['error' => 'User not found']));
            return $response->withStatus(404)->withHeader('Content-Type', 'application/json');
        }
        $data = json_decode($request->getBody()->getContents(), true);
        $updates = [];
        // Validate role update
        if (isset($data['role'])) {
            $newRole = $data['role'];
            if (!in_array($newRole, ['admin','user','accountant'], true)) {
                $response->getBody()->write(json_encode(['error' => 'Invalid role']));
                return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
            }
            $updates['role'] = $newRole;
        }
        // Validate password update
        if (isset($data['password'])) {
            $newPassword = $data['password'];
            if (strlen($newPassword) < 8 || !preg_match('/[A-Za-z]/', $newPassword) || !preg_match('/\d/', $newPassword)) {
                $response->getBody()->write(json_encode(['error' => 'Password must be at least 8 characters long and contain both letters and numbers']));
                return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
            }
            $updates['password_hash'] = $auth->hashPassword($newPassword);
        }
        if (empty($updates)) {
            $response->getBody()->write(json_encode(['error' => 'No valid fields provided for update']));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Build SQL dynamically
        $setParts = [];
        $params = [];
        foreach ($updates as $field => $value) {
            $setParts[] = "$field = :$field";
            $params[":$field"] = $value;
        }
        $params[':id'] = $userIdToUpdate;
        $sql = 'UPDATE users SET ' . implode(', ', $setParts) . ', updated_at = CURRENT_TIMESTAMP WHERE id = :id';
        $stmtUpdate = $pdo->prepare($sql);
        $stmtUpdate->execute($params);
        // Log update in audit_log
        $logStmt = $pdo->prepare('INSERT INTO audit_log (organization_id, user_id, table_name, record_id, operation, changed_data) VALUES (:org, :userId, :tableName, :recordId, :operation, :changedData)');
        $logStmt->execute([
            ':org'        => $orgId,
            ':userId'     => $requestUser['user_id'] ?? null,
            ':tableName'  => 'users',
            ':recordId'   => $userIdToUpdate,
            ':operation'  => 'UPDATE',
            ':changedData'=> json_encode($updates)
        ]);
        $response->getBody()->write(json_encode(['message' => 'User updated successfully']));
        return $response->withHeader('Content-Type', 'application/json');
    });

    /**
     * Authenticate a user and return a JWT.
     *
     * POST /login
     *
     * The login route remains without a `/v1` prefix for backwards
     * compatibility.  It validates provided credentials and issues a
     * JWT containing the user id, organisation id and role.
     *
     * @param Request  $request  PSR-7 request containing a JSON payload with
     *     `username` (string) and `password` (string).  Both fields are
     *     required; missing fields result in a 400 response.
     * @param Response $response Response object used to write the JSON
     *     response.
     *
     * @return Response Returns HTTP 200 with a JSON body containing the JWT
     *     (`token`) and user identifiers on successful authentication.
     *     Returns HTTP 400 when credentials are missing and HTTP 401 when
     *     credentials are invalid.
     *
     * @throws \PDOException If a database error occurs while retrieving the user.
     *
     * @api
     * @since 1.0.0
     *
     * @example
     * ```json
     * {
     *   "username": "jdoe",
     *   "password": "Pa55word123"
     * }
     * ```
     */
    $app->post('/login', function (Request $request, Response $response) use ($container) {
        /** @var \PDO $pdo */
        $pdo = $container->get('db');
        /** @var AuthService $auth */
        $auth = $container->get(AuthService::class);
        $data = json_decode($request->getBody()->getContents(), true);
        $username = trim($data['username'] ?? '');
        $password = $data['password'] ?? '';
        if ($username === '' || $password === '') {
            $response->getBody()->write(json_encode(['error' => 'Invalid credentials']));
            return $response->withStatus(400)->withHeader('Content-Type', 'application/json');
        }
        // Look up the user
        $stmt = $pdo->prepare('SELECT id, organization_id, password_hash, role FROM users WHERE username = :username');
        $stmt->execute([':username' => $username]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$user || !$auth->verifyPassword($password, $user['password_hash'])) {
            $response->getBody()->write(json_encode(['error' => 'Invalid credentials']));
            return $response->withStatus(401)->withHeader('Content-Type', 'application/json');
        }
        $token = $auth->generateToken((int)$user['id'], (int)$user['organization_id'], $user['role']);
        $payload = [
            'token'           => $token,
            'user_id'         => (int)$user['id'],
            'organization_id' => (int)$user['organization_id'],
            'role'            => $user['role'],
        ];
        $response->getBody()->write(json_encode($payload));
        return $response->withHeader('Content-Type', 'application/json');
    });
};