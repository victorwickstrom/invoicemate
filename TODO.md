Tack! Jag kommer nu att gå igenom hela koden, databasen, swaggerdokumentet och routingfilerna för att ta fram en detaljerad TODO-lista över vad som behöver justeras, byggas klart eller förbättras för att skapa ett självständigt bokföringssystem liknande Dinero – men förbättrat.

Jag återkommer snart med en strukturerad lista med specifika åtgärdspunkter.


## Fakturor (Invoices)

* **Komplettera fakturaskapande & rader:** Implementera fullständig skapande-logik för kundfakturor. I dagsläget sparas endast fakturahuvud med 0-värden – systemet måste hantera fakturarader. När en faktura skapas ska dess `invoice_lines` sparas i databasen och fakturans totaler (exkl. moms, inkl. moms, momsbelopp osv.) beräknas och uppdateras. Se till att fakturaobjektet som returneras innehåller summerade belopp. Dessutom bör **PUT /invoices/{guid}** uppdatera rader och totaler, inte enbart huvudfält, så att ändringar i rader återspeglas i totalsummor.
* **Sekventiell numrering & statuslogik:** Säkerställ att fakturor numreras sekventiellt per organisation. Kod för att hämta nästa lediga fakturanummer finns delvis men databasschemat saknar för närvarande `organization_id` på faktura – lägg till detta för multi-tenant-stöd (annars kan nummer krocka mellan organisationer). Implementera logik för att uppdatera **status** på fakturor baserat på händelser: vid bokföring sätts status till “Booked”, och när betalningar registreras ska `payment_status` på fakturan uppdateras (t.ex. till “Paid” om fullt betald eller “Partial/Overdue” beroende på betald summa och förfallodatum).
* **Betalningar på faktura:** Bygg ut stöd för betalningar kopplade till fakturor. Det finns en `payments`-tabell och endpoint **POST /invoices/{guid}/payment**, men systemet saknar logik för att uppdatera själva fakturan (t.ex. resterande belopp, betalningsdatum, payment\_status). Lägg till beräkning av hur betalningar påverkar fakturan: summera betalningsbelopp, markera fakturan som betald om totalen är nådd, eller spara eventuellt kvarstående saldo. Ta hänsyn till `payment_date` och `payment_method` vid uppdatering.
* **E-postutskick av faktura:** Implementera funktionen **POST /invoices/{guid}/email** för att skicka fakturan via e-post. För närvarande finns endast en ruta definierad utan implementation. Bygg en tjänst som genererar faktura-PDF (alternativt HTML) och skickar e-post till kundens adress. Använd lämpligt mail-bibliotek (t.ex. PHPMailer) och fyll i `mail_out_status` och `latest_mail_out_type` i databasen för att spåra utskicket.
* **Bokföring av faktura:** Funktionaliteten för att bokföra fakturor är delvis implementerad. Säkerställ att alla scenarion täcks: kontrollera att fakturan har rader (annars returneras fel), tilldela eventuellt nästa fakturanummer om inte redan satt (om numrering sker vid bokning). Systemet skapar nu automatiskt bokföringsposter i **entries**: debet kundfordringar (konto 1100) och kredit intäkt samt moms. Verifiera att standardkontona 1100 och 2610 är korrekta för alla användare eller gör dem konfigurerbara per företag. Implementera momskontologik: istället för hårdkoda 2610 för moms, hämta rätt momskonto baserat på momskod eller konfigurering. Kontrollera att summan av genererade entries balanserar till 0 – vid obalans ska bokningen avbrytas med fel.
* **Radering & annullering:** Utöka endpoint **DELETE /invoices/{guid}** till att hantera både obokförda och bokförda fakturor. För obokförda (Draft) kan en fysisk radering ske, men för bokförda bör systemet markera fakturan som borttagen (t.ex. sätta `deleted_at` och/eller en status “Deleted”) istället för att ta bort raden. Överväg att införa automatik för kreditnota (t.ex. föreslå att användaren skapar kreditnota istället för att radera en bokförd faktura).

## Kreditnotor (Credit Notes)

* **Skapa & numrera kreditnotor:** Implementera fullständig hantering av kreditnotor för kundfakturor. Det finns en databasstruktur (`credit_note` och `credit_note_lines`) samt en rudimentär endpoint för att generera en kreditnota från faktura, men flera delar saknas. Säkerställ att kreditnotor får ett unikt löpnummer (`number`). Just nu sätts numret slumpmässigt med `rand()`, vilket måste ersättas med sekventiell numrering per organisation, liknande fakturor. Lägg till `organization_id` i **credit\_note**-tabellen (i nuläget saknas koppling till organisation, vilket är en lucka i multi-tenant-miljön).
* **Fakturering av kreditnota:** Skapa API-endpoints för att hämta, lista och bokföra kreditnotor. Använd en liknande struktur som för fakturor (t.ex. **GET /v1/{orgId}/credit-notes**, **GET /credit-notes/{guid}**, **POST /credit-notes/{guid}/book**). Vid bokföring ska kreditnotan generera bokföringsposter som är omvända mot en vanlig faktura: kredit kundfordringar och debet intäktskonto/moms för att nollställa skulden. Status på kreditnotan ska uppdateras till “Booked” när den bokförs.
* **Kreditnotans rader och koppling:** Säkerställ att kreditnotans rader hanteras korrekt. När en kreditnota genereras från en faktura bör motsvarande rader skapas i `credit_note_lines` baserat på originalfakturans rader (med negativa kvantiteter eller belopp). I dagsläget kopieras endast totalbelopp och huvudfält. Bygg ut funktionen **createCreditNote** så att den:

  * Kopierar varje `invoice_line` från fakturan till en `credit_note_line` med samma beskrivning och belopp fast negativt (alternativt använder positiv mängd men identifierar raden som kredit).
  * Sätter kreditnotans totalsummor (`total_excl_vat`, `total_vat`, `total_incl_vat` etc.) till motsvarande negativa värden av fakturans.
  * Länkar kreditnotan till ursprungsfakturan via fältet `credit_note_for` (redan i bruk).
* **Avvikelser i modell vs. API:** Jämför kreditnotans databasmodell med API-specen. I `credit_note`-tabellen finns fältet `contact_guid` beskrivet som “Kundens GUID i Dinero” – i vår kontext ska detta motsvara vårt interna kontaktGUID. Kontrollera att API-modellen för kreditnota använder samma fältnamn (troligen `contactGuid`) och justera eventuella namn eller datatyper vid behov. Se även till att fält som `fik_code`, `deposit_account_number`, `mail_out_status` finns med i modellen – om de inte används i funktionaliteten kan de antingen implementeras (t.ex. FIK-kodgenerering för OCR-betalningar) eller tas bort för att förenkla.

## Offerter (Trade Offers)

* **Implementera CRUD för offerter:** Lägg till stöd för **Trade Offers** som i Dinero används för offerthantering. Databastabellerna `trade_offer` och `trade_offer_lines` finns definierade, men motsvarande endpoints saknas eller är ofullständiga. Skapa endpoints för att skapa en offert (**POST /v1/{orgId}/offers**), hämta en offert (**GET /v1/{orgId}/offers/{guid}**), uppdatera (**PUT**) och lista offerter per organisation. Offerten ska likna fakturamodellen men med status som t.ex. “Draft”, “CustomerAccepted”, “CustomerDeclined” etc. enligt API-specifikationen.
* **Generera faktura från offert:** Implementera logik för att konvertera en accepterad offert till en faktura. Fältet `generated_vouchers` i `trade_offer` antyder att en eller flera fakturor kan skapas utifrån offerten. Inför en endpoint, t.ex. **POST /v1/{orgId}/offers/{guid}/invoice**, som bokför offerten som accepterad och skapar en ny faktura (och eventuella fakturarader) baserat på offerten. Uppdatera `trade_offer.status` till “Invoiced” eller liknande och registrera den nya fakturans GUID i `generated_vouchers`.
* **Sekventiella offertnummer:** Säkerställ att även offerter numreras unikt per organisation. `trade_offer`-tabellen har fältet `"number"` för löpnummer. Implementera liknande funktion som för fakturor – hämta max befintligt offertnummer per org och öka med 1 vid skapande. Detta förhindrar krockar och ger spårbarhet.
* **Hantera offertrader:** På samma sätt som fakturor behöver offerten kunna ta emot flera rader (`trade_offer_lines`). Implementera att **POST/PUT** för offerter hanterar en lista av rader (produkt, beskrivning, kvantitet, pris etc.) och sparar dessa i `trade_offer_lines` för att kunna visas och senare överföras till faktura. Kontrollera att fältnamn mappar mot API\:et (exempelvis `productGuid`, `quantity`, `unit`, etc. finns i tabellen).

## Kontakter (Contacts)

* **Saknade endpoints & funktioner:** Bygg ut kontaktmodulen med full CRUD. Skapa endpoints för att lista alla kontakter för en organisation (**GET /v1/{orgId}/contacts**), hämta detaljer för en specifik kontakt (**GET /contacts/{contactGuid}**), uppdatera kontakt (**PUT/PATCH /contacts/{contactGuid}**), samt inaktivera/radera kontakt (**DELETE /contacts/{contactGuid}** med soft-delete via `deleted_at`). Just nu verkar endast grundläggande skapande hämtning vara planerad, så dessa behöver kompletteras.
* **Fälthantering och validering:** Kontaktdatamodellen har många fält – se till att API-modellen matchar dessa. Validera obligatoriska fält som `name` och `country_key` vid skapande. Hantera boolean-fält (`is_person`, `is_member`, `is_debitor`, `is_creditor`, etc.) korrekt genom att konvertera inkommande true/false till 1/0 och respektera dem vid filtrering (t.ex. möjligheten att lista endast kunder eller endast leverantörer baserat på is\_debitor/is\_creditor).
* **Kontaktens organisationstillhörighet:** I databasen är primärnyckeln definierad som (organization\_id, contact\_guid) för att garantera unika GUID per organisation. Säkerställ att alla kontaktendpoints använder `organization_id` från JWT eller URL för att isolera åtkomst – en användare i organisation A ska inte kunna nå en kontakt i org B. Lägg även till logik som automatiskt sätter `organization_id` på den nya kontakten utifrån URL\:en vid **POST /contacts** (istället för att klienten ska skicka in det).
* **Kontaktanteckningar:** Utnyttja tabellen `contact_notes` för att spara noteringar per kontakt. Implementera endpoints för att lägga till en anteckning till en kontakt (**POST /contacts/{contactGuid}/notes**), lista anteckningar (**GET /contacts/{contactGuid}/notes**), uppdatera och ta bort enskilda anteckningar. Detta gör CRM-delen mer komplett. Inkludera fält som `author_name`, `note_date` etc. vid skapande, och markera eventuellt borttagna anteckningar via `deleted_at` istället för fysisk radering för spårbarhet.
* **Statiska register (länder, status mm):** Inför hjälp-endpoints för värdelistor kopplade till kontakter. T.ex. **GET /countries** för att hämta en lista av landskoder/namn (DK, SE, osv.) om sådana behövs för `country_key`. Även eventuella listor för `company_type_key` (typer av företag) och `invoice_mail_out_option_key` kan erbjudas så att klienten vet vilka värden som är giltiga. Dessa kan hämtas från konfiguration eller hårdkodas likt momskoder.

## Bilagor & Filer (Attachments & Files)

* **Filuppladdning:** Implementera endpoint för att ladda upp filer till systemet (**POST /v1/{orgId}/files**). Uppladdade filer ska sparas i `files`-tabellen med unikt `file_guid` som primärnyckel. Använd multipart/form-data där filens innehåll skickas; vid mottagning genereras ett GUID och filen skrivs till disk (t.ex. `uploads/`-katalog). Spara metadata som filnamn, filtyp (`extension`), storlek, uppladdande användare och tidpunkt. Returnera `file_guid` och metadata i svaret.
* **Filkryptering:** Integrera server-side kryptering av filer enligt specifikation. Enligt README ska alla uppladdade filer krypteras med AES-256-CBC innan lagring. Implementera detta genom att hämta nyckeln från `FILE_ENCRYPTION_KEY` (miljövariabel) och använda PHP OpenSSL-funktioner för att kryptera filens byteström. Vid nedladdning (**GET /v1/{orgId}/files/{fileGuid}**) ska filen läsas, dekrypteras med nyckeln och skickas tillbaka till klienten med korrekt MIME-typ. Se till att en statisk utvecklingsnyckel endast används i dev-miljö – i produktion måste `FILE_ENCRYPTION_KEY` sättas för säkerhet.
* **Koppling mellan filer och affärsobjekt:** Använd tabellen `attachments` för att länka uppladdade filer till domänobjekt som fakturor, verifikationer m.m.. Implementera exempelvis **POST /v1/{orgId}/invoices/{invoiceGuid}/attachments** som tar ett `file_guid` och skapar en rad i `attachments` med referens till invoice (som `document_guid`). Detta möjliggör att en faktura kan ha flera bilagor (PDF-kvitton, bilder etc.). På motsvarande sätt, säkerställ att när en faktura eller verifikation raderas (eller markeras som bokförd), bilagor inte förloras: använd `ON DELETE CASCADE` för att automatradera kopplingar eller markera bilagor som orphans.
* **Filanvändningsstatus:** Utnyttja fältet `file_status` i `files`-tabellen för att indikera om en fil är använd (“Used”) eller inte. Vid uppladdning sätts status initialt till “Unused”, och när filen kopplas via `attachments` till en faktura/verifikation uppdateras status till “Used”. Implementera logik som hindrar radering av filer som är “Used” om det behövs, och ev. en rutin som gallrar orefererade filer efter viss tid.
* **Åtkomstkontroll:** Kontrollera att endast behöriga kommer åt filerna. Endpoints för att ladda upp/hämta filer ska använda JWT och säkerställa att filens `organization_id` matchar användarens organisation. Känsliga filer (t.ex. bokföringsunderlag) skyddas därmed mot otillbörlig åtkomst.

## Kontoplan & Moms (Chart of Accounts & VAT)

* **Koppling till organisation:** Åtgärda designlucka i `account`-tabellen. För närvarande saknas `organization_id` på kontoplanen, vilket innebär att alla organisationer skulle dela kontoplan. För full multi-tenant-stöd bör varje konto knytas till en organisation (lägg till `organization_id` som kolumn och del av primärnyckeln eller en separat PK). Alternativt, om avsikten är en gemensam kontoplan, får API\:et begränsa ändringar per org och bara filtrera konton relevant för respektive organisation. Rekommenderat är dock unika kontoplaner per org, särskilt då företag kan vilja anpassa kontoplanen.
* **API-endpoints för konton:** Bygg ut endpoints enligt Dinero-standarden. Implementera t.ex. **GET /v1/{orgId}/accounts** som listar konton (med möjlighet till filtrering på kategori som `categoryFilter`) och **POST /v1/{orgId}/accounts** för att skapa nya konton. Klienten ska kunna specificera fält som *AccountNumber*, *Name*, *VatCode*, *Category* etc., varpå systemet skapar kontot i databasen. Validera att *AccountNumber* är unikt inom organisationen och obligatoriskt. Om kontot faller utanför tillåtet intervall (t.ex. depositionskonto vs resultatkonto) bör API\:et returnera fel eller varning enligt behoven.
* **Standardkonton och flaggor:** Utnyttja fälten `isDefaultSalesAccount`, `isDefault` (för t.ex. standardinsättningskonto) och `isHidden`. Lägg in logik som vid skapande eller uppdatering ser till att endast ett konto per kategori kan ha vissa flaggor (t.ex. endast ett konto markeras som default deposit account). API\:et bör även exponera dessa fält så att klienten kan välja standardkonton.
* **Momsregister & koder:** Istället för att hårdkoda momskoder i koden, populera tabellen `vat_type` med de danska momssatserna vid initiering. Skapa en endpoint **GET /v1/{orgId}/vatTypes** som läser från databasen och returnerar tillgängliga momstyper (kod, namn, sats). Detta ger mer flexibilitet om momssatser uppdateras. Associera även konton med momskoder via `vatCode`-fältet på kontot; överväg validering som garanterar att kontots momskod finns i `vat_type`.
* **Momsberäkning i fakturor:** Säkerställ att momsberäkningen vid fakturering använder momskoder korrekt. När produkt-/fakturarader skapas bör momssatsen sättas enligt vald `vatCode` på raden, och totalsummor för momsbelagda respektive icke-momsbelagda belopp (`total_vatable_amount`, `total_non_vatable_amount`) uppdateras. I nuläget räknas totaler i **fetchInvoiceTotals()** med en generell vatRate. Förbättra detta genom att:

  * Ta `vat_code` per rad (t.ex. “U25” för 25% utgående moms, “none” för momsfritt) och slå upp motsvarande `vat_rate` från `vat_type` tabellen.
  * Beräkna moms per rad individuellt och summera.
  * Fylla i `vat_code` och `vat_rate` på varje `invoice_line` (databasschemat har dessa fält).
  * Uppdatera fakturans `total_vat` och övriga totalsfält innan bokföring.

## Verifikat & Bokföringsposter (Manual Vouchers & Ledger Entries)

* **Utöka verifikationsrader (manual\_voucher\_lines):** Inför en separat tabell för verifikationsrader eller nyttja befintlig. Just nu lagras manuella verifikationers rader enbart i minnet vid bokning (endast `manual_voucher`-huvudet sparas i DB). Skapa en tabell `manual_voucher_line` (om den inte redan finns) för att lagra rader med konto, beskrivning, belopp, momskod m.m. för varje draft-verifikation. Anpassa **POST /vouchers/manual** så att inkommande rader sparas i denna tabell när en verifikation skapas som utkast. Detta möjliggör att användaren kan spara och senare redigera verifikationsrader innan bokföring.
* **Bokföra manuell verifikation:** Nuvarande implementation av **POST /vouchers/manual/{guid}/book** balanserar verifikationen och skapar bokföringsposter korrekt. Kontrollera att funktionaliteten täcker alla scenarion:

  * **Periodlåsning:** Koden lägger till `is_locked` på `accounting_year` om saknas och hindrar bokning om året är låst. Behåll detta, men flytta gärna kontrollen till en gemensam funktion då samma logik upprepas på flera ställen (faktura- och inköpsbokning).
  * **Verifikationsnummer:** Systemet genererar nästa lediga `voucher_number` för verifikationen vid bokning. Säkerställ att detta fungerar i en multi-user miljö (lägg ev. en unik index eller låsning vid select max+1). Efter bokning uppdateras status till 'Booked' och `booking_time` sätts – detta är korrekt.
  * **Entries-postning:** För varje rad i verifikationen insertas en motsvarande rad i `entries`-huvudboken. Eftersom varje rad i en manuell verifikation redan representerar en debet eller kredit, blir summan noll om balansering är uppfylld. Bibehåll kontrollen av balans och returnera fel om debet != kredit.
* **Lista & filtrera verifikationer:** Inför endpoint **GET /v1/{orgId}/vouchers/manual** som listar organisationens manuella verifikationer (både utkast och bokförda). Tillåt filtrering på datumintervall, status (Draft/Booked) och ev. textmatchning på beskrivning eller nummer. Detta underlättar för användare att överblicka alla verifikat.
* **Journal (entries) åtkomst:** Bygg en endpoint för att läsa huvudbokens poster, t.ex. **GET /v1/{orgId}/entries** med parametrar för datumintervall eller konto. Detta kan användas för att kontrollera att alla affärshändelser registrerats korrekt. Varje `entry` har ett unikt `entry_guid` och referenser till voucher nummer/typ – överväg att inkludera tillhörande verifikations-/fakturanummer i svaret för spårbarhet.
* **Data-integritet i huvudboken:** Använd databaskonstraint och triggers för att stärka integriteten. Överväg att införa FOREIGN KEY mellan `entries.voucher_number` + `voucher_type` och respektive källtabell (svårt i SQLite, men triggers kan kontrollera existens). Befintliga triggers för audit log täcker INSERT/UPDATE/DELETE på centrala tabeller – utöka vid behov med kontrolltrigger som t.ex. förhindrar att en bokförd verifikation ändras i efterhand utan att skapa en offset-post.

## Räkenskapsår & Periodlåsning (Accounting Years)

* **Lista & hantera räkenskapsår:** Säkerställ att **GET /v1/{orgId}/accountingyears** är implementerad för att lista alla räkenskapsår för en organisation. Enligt API-spec ska nya år kunna uppstå genom bokning i nästkommande år, men det kan vara bra att även ha ett explicitt skapande. Implementera **POST /v1/{orgId}/accountingyears** som skapar ett nytt år (om t.ex. man vill fördefiniera året). Validera att `from_date` är dagen efter föregående års `to_date` för att undvika glapp eller överlapp.
* **Periodlåsning:** Funktionen för periodlåsning är delvis på plats via `is_locked` flaggan. Bygg en endpoint **PUT /v1/{orgId}/accountingyears/{id}/lock** som sätter is\_locked=1 (respektive `/unlock` för att häva låsning). Endast admin-användare ska få utföra detta. När ett år låses ska systemet vägra bokföringshändelser (fakturor, verifikat, etc.) med datum inom det året – dagens bokningsfunktioner kontrollerar detta redan men se till att kontrollen finns på alla relevanta ställen (kundfakturor, leverantörsfakturor, manuella verifikationer, ev. betalningsregistrering).
* **Årssummering och ingående balanser:** Överväg att automatisera överföring av ingående balanser (primo) vid nytt räkenskapsår. T.ex. när 2024 skapas, beräkna summan per konto från 2023 och skapa prima nota. Tabellen `reports` kan eventuellt användas för att lagra ingående balans (report\_type 'primo'). Detta skulle vara en förbättring för robusthet, så att användaren enkelt får med sig balanser vid årsskifte.

## Påminnelser (Reminders)

* **Skapa & lista påminnelser:** Implementera endpoints för att hantera betalningspåminnelser kopplade till fakturor. Tabellen `reminder` definierar omfattande fält för påminnelser, men funktionaliteten är inte klar. Skapa **POST /v1/{orgId}/invoices/{invoiceGuid}/reminders** för att skapa en ny påminnelse (initialt som utkast `is_draft=1`). Generera nästa påminnelsenummer för den fakturan (1, 2, 3) automatiskt baserat på hur många påminnelser som redan finns (`number`-fältet). Returnera de relevanta fälten (t.ex. titel, text, avgifter) så att klienten kan visa en påminnelse.
* **Beräkning av avgifter & ränta:** Utnyttja fälten `with_fee`, `fee_amount`, `with_interest_fee`, `interest_amount` etc. för att automatisera kostnadsberäkning på påminnelser. När en ny påminnelse skapas eller bokförs, beräkna eventuellt en påminnelseavgift och dröjsmålsränta baserat på fakturans data:

  * Om `with_fee` är true, använd standard `reminder_fee` (angiven på fakturan) eller organisationspolicy för att sätta `fee_amount`.
  * Om `with_interest_fee` är true, räkna ut ränta från förfallodatum till påminnelsedatum: använd fakturans `reminder_interest_rate` (årlig ränta) och fakturabelopp för att kalkylera `interest_amount`. Fyll även i textfälten som beskriver räntan (`interest_amount_text`) för fakturaspecifik kommunikation.
  * Summera eventuella tidigare påförda avgifter (`accumulated_fees_and_interest_amount`) om detta är påminnelse 2 eller 3, så att den totala kostnaden framgår.
* **Bokföra & skicka påminnelse:** Skapa endpoint **POST /v1/{orgId}/invoices/{invoiceGuid}/reminders/{id}/book** som markerar en påminnelse som skickad (`is_draft=0`). Vid bokning bör fakturans status eventuellt uppdateras (t.ex. från “Overdue” till “Reminded”) och `paid_amount` fält hanteras om betalning inkommit under tiden. Dessutom, implementera **POST /v1/{orgId}/invoices/{invoiceGuid}/reminders/{id}/email** för att skicka påminnelsen via e-post till kundens adress. Använd mallar för ämne och meddelande; en endpoint för att förhandsvisa e-posttext (**GET /reminders/{id}/email/template**) kan följa Dinero API. Logga varje utskick i `reminder_email_log` med timestamp, mottagare, ämne och innehåll.
* **Inkassovarsel & kompensationsavgift:** Systemet har stöd för inkassovarning (`with_debt_collection_warning`) och kompensationsavgift (`with_compensation_fee`), men dessa måste appliceras i logiken. Avgör enligt affärsregler när inkassovarning ska bifogas – t.ex. på sista påminnelsen – och sätt `debt_collection_notice_text` i meddelandet. Om kompensationsavgift är tillåten (`compensation_fee_available`), lägg på lagstadgad avgift (typiskt för B2B-fakturor) och fyll i `compensation_fee_amount` samt text. Denna logik kan baseras på org-inställningar eller fakturatyp.
* **Avvikelser mellan DB & API:** Säkerställ att API-modellen för påminnelser stämmer med databasen. Exempel: API kan förväntas kalla fält “title”, “description” osv. lika som kolumnerna. Notera att `voucher_guid` i `reminder` refererar till fakturan – använd detta för att koppla påminnelse till faktura-ID (Dinero API använder ofta invoice GUID i path). Om vår implementation skiljer sig (ex. annan path-struktur) justera för kompatibilitet.

## Rapporter (Reports)

* **Automatisk rapportgenerering:** Förbättra hanteringen av ekonomiska rapporter (resultat- och balansrapport). I nuläget lagras rapportdata i tabellen `reports` och API-endpoints hämtar poster därifrån, men det förutsätter att data redan finns. Implementera en tjänst som kan generera rapportposter baserat på huvudbokens (`entries`) data i stället för att manuellt mata in dem via **POST /reports**. Exempelvis: vid anrop till **GET /v1/{orgId}/{year}/reports/balance**, om tabellen saknar poster för det året, beräkna saldon för alla balanskonton från `entries` och insert\:a dem i `reports`-tabellen (eller returnera direkt utan mellanlagring). Detta gör systemet robustare då rapporter alltid speglar aktuella bokföringsdata.
* **Uppdatera/dimensionera reports-tabellen:** Om rapportdata ska genereras on-the-fly kan man överväga att ta bort möjligheten att manuellt **POST/PUT** rapportposter – annars riskerar data i `reports` att bli inkonsekvent med verkliga bokföringen. Alternativt, behåll `reports` som cache/tabell för frysta rapporter (t.ex. årsavslut), men då bör **POST /reports** endast användas av en admin-operation som skapar en rapport vid ett visst datum. Klargör användningsfallet och justera koden därefter.
* **Fler rapporttyper:** Överväg att implementera momsrapport som en egen endpoint (t.ex. **GET /v1/{orgId}/{year}/reports/vat** eller query-param). Den skulle summera utgående och ingående moms för en period. Denna är efterfrågad som valfri förbättring och kan nyttja entries samt vat\_type för att gruppera belopp per momskod.
* **Utdataformat:** Kontrollera att rapport-API\:ets utdata matchar förväntningarna. Dinero API kan presentera rapporter både som listor per konto och summeringar. I vår tabell finns kolumner som `show_zero_account`, `include_summary_account` etc. för att styra visningen. Se till att API\:et tolkar dessa flags – t.ex. om *show\_zero\_account* = false, filtrera bort konton med nollsaldo i svaret. Likaså, om *include\_ledger\_entries* = 1 kunde rapporten bifoga en lista av underliggande verifikationsrader för varje konto. Just nu returnerar vi bara raw data från tabellen; förbättra genom att applicera dessa logikfilter innan JSON-svar.

## Organisationer & Användare (Organizations & Users)

* **Organisationsendpoints:** Lägg till stöd för att hämta och uppdatera organisationsinformation. Skapa **GET /v1/{organizationId}** som returnerar organisationens profil (namn, adress, kontaktuppgifter, inställningar som is\_vat\_free m.m. enligt `organizations`-tabellen). Tillåt även **PUT /v1/{organizationId}** för att admins ska kunna uppdatera uppgifter (t.ex. adressändring, e-mail, telefon). Då `organizations` innehåller flags som `is_vat_free`, se till att dessa kan ändras via API för t.ex. momsregistrering.
* **Skapa ny organisation:** Om systemet ska stödja flera organisationer utöver initial seed, behövs en endpoint för att skapa organisationer (t.ex. **POST /v1/organizations**). Detta skulle möjliggöra att en användare (kanske global admin) registrerar ett nytt företag i systemet. Vid sådan skapelse bör även ett första räkenskapsår initieras och en admin-användare knytas till organisationen. Notera att detta kräver säkerhetsöverväganden (kanske endast interna admins får göra det).
* **Användarregistrering & behörigheter:** Det finns grundläggande stöd för att skapa användare via **POST /v1/{orgId}/users**. Finslipa denna genom att:

  * Validera lösenordskomplexitet och kanske kräva minsta längd.
  * Kontrollera att `username` är unikt globalt eller per org (nuvarande kod kollar globalt). Om det ska kunna finnas samma användarnamn i olika org, ändra unicitetskontrollen till att inkludera organization\_id.
  * Tillåt uppdatering av användare (byte av roll eller lösenord) via **PUT /users/{id}** för admins. Här ska lösenordet hash\:as om det byts – använd `AuthService->hashPassword` för konsekvens.
* **JWT & AuthService:** Förbättra autentiseringstjänsten. I nuläget används JWT med en hemlighet, men `AuthService` i koden är ofullständig (den accepterar enbart token "test" som giltig). Implementera faktiskt JWT-validering – exempelvis genom `firebase/php-jwt` bibliotek – så att tokens signeras med `JWT_SECRET` (miljövariabel) och valideras korrekt. `AuthService->generateToken` bör generera en JWT innehållande `user_id`, `organization_id` och `role` giltig i 24h. `AuthService->validateToken` ska verifiera signaturen och utge payload. Detta höjer säkerheten avsevärt.
* **Rollhantering:** Systemet stödjer rollerna 'admin' och 'user'. Säkerställ att rollkontroller appliceras på alla admin-krävande endpoints (t.ex. bokföring, backup, användaradministration) via middleware eller i respektive route (det görs t.ex. i bokföringsrutterna). Överväg att utöka rollsystemet om behov finns i framtiden (t.ex. 'auditor' roll med endast läsbehörighet). I så fall bör `users.role`-kolumnens CHECK uppdateras för nya värden.

## Webhooks & Notifieringar

* **Prenumerationsendpoints:** Implementera API\:ets webhook-endpoints för att möjliggöra integrationer. Enligt specifikationen ska vi ha bl.a.: **POST /v1/{orgId}/webhooks/subscribe** (med eventId och uri), **DELETE /v1/{orgId}/webhooks/unsubscribe**, **GET /v1/{orgId}/webhooks/subscriptions** (lista aktiva prenumerationer) och **GET /v1/{orgId}/webhooks/events** (lista möjliga events). Bygg dessa endpoints så att de manipulerar tabellerna `webhook_subscriptions` och `webhook_events`. T.ex. **subscribe** ska lägga till en rad i `webhook_subscriptions` med angivet event (om det finns i `webhook_events`) och mottagar-URL. **unsubscribe** tar bort motsvarande rad.
* **Utlösning av webhooks:** Koppla webhook-händelser till systemets affärslogik. Definiera vilka actions som genererar events (t.ex. Invoice Created, Invoice Booked, Payment Added, Contact Created, etc. som listade i `webhook_events` tabellen). Efter varje sådan händelse, implementera en asynkron notifiering: t.ex. en bakgrundsprocess eller omedelbart efter commit, hämta alla subscriptions för eventet och gör en HTTP POST till respektive `uri` med relevant payload (t.ex. fakturaobjektets JSON). För stabilitet kan anropen köas eller ske i bakgrundstråd så att API-svaret till klient inte fördröjs.
* **Säkerhet & signatur:** Inför en säkerhetsmekanism för webhook-callbacks. Ofta skickar man med en hemlig token eller signatur med webhook-anropet så mottagaren kan verifiera att det kommer från vårt system. Det kan vara en enkel statisk secret per org eller en HMAC av meddelandet. Lägg till detta som förbättring – t.ex. ett hemligt fält i `webhook_subscriptions` och inkludera en `X-Signature` header i anropen. Dokumentera för konsumenterna hur de ska verifiera webhooken.
* **Felhantering:** Bygg in återförsökslogik för webhooks. Om en mottagar-URL svarar med fel eller timeout, bör systemet försöka igen efter en tid (ex. exponential backoff upp till ett max). Detta kräver att misslyckade leveranser loggas. Man kan utöka `webhook_subscriptions` med t.ex. senaste status eller ha en separat log för leveransförsök. För nu kan en förenklad strategi vara att logga fel i Monolog och låta administratör hantera manuellt, men notera behovet för robusthet.

## Säkerhet & Kodstruktur

* **Åtkomstkontroll per route:** Genomför en fullständig genomgång av alla endpoints för att säkerställa att de respekterar behörighet och organisationsgränser. Tidigare fanns vissa endpoints utan org-filter (t.ex. initiala invoice-rutter saknade `WHERE organization_id`), men nyare kod har lagt till det. Verifiera att **samtliga SQL-frågor** i routes inkluderar `organization_id = :orgId` där det är relevant, så att ingen kan läsa/ändra andra organisationers data genom att manipulera URL\:er.
* **Inputvalidering & sanitisering:** Förbättra valideringen av klientdata. Mycket av datan sätts direkt via parametrar i SQL (vilket minskar SQL-injections genom PDO-bindningar), men det finns ställen där dynamiska SQL-byggen förekommer, t.ex. sorteringsfält. Inför whitelists för sådana parametrar: kontrollera att `sort`-fält bara innehåller tillåtna kolumnnamn (som “number” eller “invoice\_date”) och inga otillåtna tecken, innan de injectas i queryn. Likaledes, validera ID-format (GUID/UUID) för t.ex. faktura- och kontaktGUID\:er tidigt och returnera 400 vid fel format, istället för att låta dem gå till databasen.
* **Exception handling & felformat:** Lägg till en global JSON-felhanterare. I routes.php inkluderas JsonErrorMiddleware, se till att den är korrekt implementerad för att fånga oförutsedda undantag och returnera JSON-formaterade felmeddelanden istället för PHP-stacktraces. Detta höjer robustheten och ger klienter konsekventa felresponser.
* **Refaktorisering av routes till controllers:** Överväg att omstrukturera koden för bättre läsbarhet och testbarhet. Istället för att definiera alla funktioner inline i routes-filer, kan man introducera klasser (t.ex. InvoiceController, ContactController) med metoder för respektive endpoint. Slim 4 stödjer att kalla kontroller-metoder direkt. Detta skulle minska duplicering – vi ser t.ex. mycket gemensam kod för kontroll av låst period, sekventiell numrering, audit-loggning, som kunde bli gemensamma hjälpfunktioner eller traits.
* **Audit-logik & triggers:** Audit-funktionen är delvis klar via triggers som loggar INSERT/UPDATE/DELETE i `audit_log`-tabellen. Finslipa denna genom att säkerställa att **alla** viktiga tabeller täcks. I migrationsfilen finns triggers för invoice, manual\_voucher, purchase\_voucher, entries, contacts etc., men saknas för t.ex. invoice\_lines, payments, kanske produkter. Utöka triggers för dessa också om spårbarhet krävs. Vidare, vid högre nivå-händelser som bokföring används `operation = 'BOOK'` och man loggar changed\_data manuellt i koden – fortsätt med detta så att även affärshändelser loggas (inte bara rå DB-change). Överväg om audit\_log ska replikera gamla och nya värden eller bara nya; nu sparas t.ex. vid UPDATE både old och new som JSON vilket är utmärkt för historik.
* **Prestanda & skalbarhet:** Förbered för ökad datamängd. SQLite fungerar i utveckling, men för många samtidiga användare eller större datamängder kan en migrering till MySQL/Postgre bli aktuell. Håll SQL frågorna relativt standardiserade för enkel portning. Inför pagination (vilket delvis finns, t.ex. page/pageSize på invoice list) på alla list-ändpunkter som potential har många resultat (kontakter, verifikationer, entries, etc.). Använd index på viktiga kolumner: primärnycklar finns, men indexera även foreign keys som organization\_id i stora tabeller för snabb filtrering.

## Beroenden & Integrationer

* **Lägg till nödvändiga paket:** Uppdatera `composer.json` för att inkludera bibliotek som behövs för full funktionalitet. Till exempel används `Uuid::uuid4()` i koden, men **ramsey/uuid** är inte listad som dependency – lägg till det för att generera giltiga UUID. För e-postutskick, inkludera ett mail-bibliotek (t.ex. **phpmailer/phpmailer**) om ni inte vill skriva egen SMTP-hantering. Om PDF-generering av fakturor/offert behövs för e-post eller arkivering, addera t.ex. **dompdf/dompdf** eller **mpdf/mpdf**.
* **Ta bort onödiga beroenden:** Gå igenom nuvarande dependencies och rensa sådana som inte används. T.ex. både **slim/psr7** och **nyholm/psr7** är inkluderade; det räcker oftast med ett PSR-7 implementation (Slim 4 drar in slim/psr7 som standard). Om ni inte uttryckligen använder Nyholms implementation kan den tas bort för att minska underhåll.
* **Integration med betalningslösningar:** Fundera över fälten `is_mobile_pay_invoice_enabled` och `is_penso_pay_enabled` i fakturatabellen. Dessa antyder integrationer med MobilePay og Pensopay. Om detta är på er roadmap, planera att inkludera deras SDK\:er eller API-anrop. T.ex. om en faktura markeras med MobilePay, kan systemet anropa MobilePays API för att skapa en betalningsbegäran. För närvarande görs inget med dessa flags – om integration inte ska byggas nu, kan fälten utelämnas från API-respons för att inte förvilla användaren.
* **Externa API-anrop och tidouts:** Om systemet ska skicka webhooks eller mail, se till att hantera externa anrop robust. Använd t.ex. GuzzleHTTP klient med rimliga timeout-inställningar för webhooks, och fånga exceptions så att de inte kraschar våra endpoints. Dessa beroenden (Guzzle, eller eventuellt symfony/http-client) kan behöva läggas till.
* **Uppdatera dokumentation för integratörer:** Säkerställ att Swagger-dokumentationen (OpenAPI) hålls uppdaterad i `swagger.json` när ni ändrar endpoints eller modeller, så att tredje part som integrerar mot ert API får korrekta specifikationer. Om några beroenden som påverkar funktionaliteten läggs till (t.ex. stöd för nya filformat, nya auth-metoder) bör detta också framgå i dev-portalen.

## Backup & Återställning

* **Backup-endpoints:** Fullfölj implementationen av backup-funktioner under admin-endpoints. Enligt README finns **POST /v1/{orgId}/admin/backup/db** för databasen. Säkerställ att denna faktiskt dumpar SQLite-databasen till en säker plats (t.ex. `backups/organization_<ID>_<date>.sqlite`). Implementera även rotation: behåll de X senaste backuperna per org och ta bort äldre för att spara utrymme (som nämnt, de fem senaste behålls). Lägg till motsvarande endpoint för att backup\:a uppladdade filer (t.ex. zippa `uploads/` katalogen) och eventuellt en **GET /admin/backup** för att lista tillgängliga backup-filer eller ladda ned dem.
* **Automatisering:** Eftersom kontinuerlig backup är kritiskt för robusthet, inför en mekanism för schemalagd backup. Detta ligger visserligen utanför själva API\:et, men systemet bör vara designat för att en cron-jobb eller liknande kan anropa backup-endpoints dagligen. Alternativt kan en intern scheduler (om ni använder t.ex. Roadrunner eller en bakgrundstråd) trigga backups. I dokumentationen/TODO nämns automatiska backup-rutiner – se till att plan finnas för detta, även om själva crontab sätts upp separat.
* **Återläsning av backup:** Överväg att erbjuda en **restore**-funktion för administrators. T.ex. **POST /v1/{orgId}/admin/restore** som tar en backup-fil (tidigare exporterad) och ersätter nuvarande databas/filer med dess innehåll. Detta är riskfyllt att exponera via API (man vill ogärna att vem som helst kan trigga det), men för helhets skull kan en intern restaureringsprocedur dokumenteras. Om det inkluderas, skydda det strikt med admin-roll och kanske extra verifikation.
* **Test av backup-integritet:** Inför verifiering att backup-filerna inte är korrupta. T.ex. efter skapad databasdump, försök läsa den (öppna SQLite-filen och kontrollera några tabeller) innan den markeras som lyckad. Likaså för fil-arkiv, kontrollera att de går att packa upp. Logga resultat av dessa tester så att ni tidigt upptäcker backup-problem.

Med ovanstående åtgärder grupperade per modul kommer bokföringssystemet bli mer komplett, robust och skalbart – likt (och på flera punkter förbättrat jämfört med) Dineros backend. Varje modul får nödvändiga funktioner och dataintegriteten förstärks, samtidigt som kodbasen struktureras för underhåll och tillväxt.
