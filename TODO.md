invoiceRoutes.php:  
- **Moms- och kontologik:** Ta bort hårdkodning av konton (t.ex. 1100 och 2610) och hämta rätt konton från kontoplanen eller momskod. Säkerställ att **moms** bokförs på korrekt konto baserat på momskod istället för alltid 2610, och att kundfordringskontot (t.ex. 1100) kan konfigureras per organisation.  
- **Fakturabetalning & status:** Klargör hanteringen av `status` kontra `payment_status`. I dagsläget uppdateras endast `payment_status` (“Paid”, “Partial”, “Overdue” etc) vid betalning – överväg att även sätta `status` till “Paid” när fakturan är slutbetald eller använd enbart `payment_status`. Implementera logik för **påminnelseavgift och dröjsmålsränta**: utnyttja fälten `reminder_fee` och `reminder_interest_rate` genom att tillämpa dem när en faktura blir förfallen (t.ex. generera betalningspåminnelse med avgift och ränta).  
- **Unik fakturanummerering:** Säkerställ att fakturor får sekventiella nummer per organisation. Koden hämtar nästa nummer med `MAX(number)+1` men saknar låsning – lägg till unik index per org på `number` och hantera transaktionellt för att förhindra dubbletter vid samtidiga skapanden.  
- **Credit note-hantering:** Använd organisationens ID vid skapande av kreditnotor (lägg till `organization_id` i `credit_note`-tabellen och i INSERT-satsen) så att multi-tenant-data isoleras korrekt. Ta bort den temporära funktionen `ensureCreditNoteHasOrgColumn` genom att migrera schemat i förväg.  
- **Kodstruktur:** Filen innehåller omfattande affärslogik i route-closures – överväg att bryta ut logiken till controller- eller service-klasser. Detta skulle förbättra läsbarhet och efterlevnad av moderna PHP-principer (t.ex. enkeltestning och Single Responsibility Principle). Dessutom bör DI-containern användas konsekvent – definiera alias `db` eller använd `$container->get(PDO::class)` istället för `$container->get('db')` för att undvika potentiella DI-konflikter.

contactRoutes.php:  
- **CVR-integration:** Utnyttja fältet `use_cvr` för att hämta företagsdata via CVR API. Om `use_cvr` är sant vid skapande/uppdatering bör systemet automatiskt kunna slå upp företagsnamn, adress m.m. baserat på angivet CVR-nummer (`vat_number`). Detta saknas idag.  
- **Validering & standardvärden:** Nu krävs flera fält (`is_person`, `is_member`, `use_cvr` etc.) i varje POST – sätt hellre rimliga defaultvärden (0 för booleans) så att inte varje fält måste skickas in manuellt. Validera e-postformat och telefonnummer (förbättra datakvalitet).  
- **Soft-delete-kopplingar:** Vid mjuk radering av en kontakt (`deleted_at` sätts) bör systemet överväga följdverkningar – t.ex. markera dess fakturor som raderade eller hindra nya fakturor. Lägg även till logik för att förhindra dubbletter (unik e-post eller kombination av namn+nummer om relevant).  
- **Efterlevnad Dinero-fält:** Säkerställ att alla fält mappas rätt mot Dinero API-modellen. T.ex. motsvarar `contact_guid` vårt interna GUID – se till att fält som `company_type_key`, `vat_region_key` etc. överensstämmer med API:ets förväntade värden eller konverteras vid utbyte.

contactStateRoutes.php:  
- **PDF-generering:** Implementera utskrift av **kontoutdrag som PDF** för en kontakt. Endpoint `/state-of-account/{guid}/pdf` returnerar nu 501 Not Implemented. Bygg en PDF-generator (t.ex. via en HTML-templates + PDF-bibliotek) som sammanställer kundens saldo och transaktioner för perioden.  
- **Mejlfunktion:** Ersätt den simulerade e-postutskickningen med riktig e-postsändning. Använd t.ex. PHPMailer eller Symfony Mailer för att skicka kontoutdraget till kundens e-post. Parametrarna `receiver`, `sender`, `subject`, `message` och `ccToSender` ska användas för att faktiskt skicka e-post (gärna med PDF:en som bifogad fil).  
- **Resultatberäkning:** Kontrollerna summerar inkomster och utgifter men returnerar alla **entries** ofiltrerat. Överväg att lägga till summerade saldo per kontakt (t.ex. totalt obetalt saldo). Därtill bör `entry_type` “Ultimo” sannolikt tolkas som ingående balans – nu filtreras de bort vid `hideClosed`, men säkerställ att logiken är korrekt för att inte exkludera relevanta transaktioner.

salesRoutes.php:  
- **Multi-tenant-bug:** Alla fakturor/kreditnotor returneras oberoende av organisation. Lägg till filtrering på `organization_id` – t.ex. förvänta `{organizationId}/sales` i stigen och använd det i WHERE-satsen, så att en användare bara ser sin organisations försäljning.  
- **Prestanda & paginering:** Nu hämtas upp till 100 poster per sida, vilket är OK, men UNION ALL-frågan kan optimeras. Överväg att lägga till explicit kolumnlista i SELECT (istället för `SELECT *`) och eventuellt separate endpoints för fakturor vs. kreditnotor om datamängden växer.  
- **Fältkonsistens:** Kontrollera att fältnamn matchar API-dokumentationen. T.ex. `updated_at` används för `changesSince`-jämförelse – se till att API:et förväntar ISO8601-tidstämplar eller liknande format. Om nödvändigt, konvertera datumformat innan jämförelse/retur.  
- **Åtgärda sortering:** Parameter `sortOrder` används direkt i SQL utan vita-listning av värden (“ASC”/“DESC”). Inför validering av sorteringsvärdet för att undvika SQL-injektion (alternativt använd parametrar eller fördefinierade konstanter).

tradeOffersRoutes.php:  
- **Statusflöden:** Implementera saknade **statusändrings-endpoints** för offerter. Idag sätts status initialt till Draft (om än en bugg: `status` saknas i INSERT – bör vara t.ex. ‘Draft’ som default) och ändras till “Invoiced” vid konvertering till faktura. Inför endpoints för att markera offert som accepterad eller avvisad av kund (mappa till `CustomerAccepted`/`CustomerDeclined`) eller av användare. Detta behövs för att täcka alla status som anges i Dinero (t.ex. om kunden accepterar en offert utan att den direkt faktureras).  
- **Konvertering till faktura:** Koden skapar en faktura av offerten men uppdaterar inte `generated_vouchers`-fältet. Fyll i `trade_offer.generated_vouchers` med den skapade fakturans GUID eller nummer (alternativt en lista om flera fakturor kan genereras) för spårbarhet.  
- **Numrering och datum:** Säkerställ att offerter får unika **offerter-nr** per organisation. Koden genererar nästa nummer med MAX()+1 – applicera samma försiktighet som för fakturor (unik index, transaktionslåsning). Dessutom bör `offer_date` inte ändras vid uppdatering – se till att den hanteras korrekt (nu sätts `updated_at` men `offer_date` förblir oförändrad, vilket är rätt).  
- **Linjeberäkning & moms:** Den inbyggda funktionen `$computeOfferTotals` använder `vat_type`-tabellen men refererar till kolumner `vatCode`/`vatRate` (versaler blandat med camelCase). Se till att momskoder hämtas rätt – uppdatera eventuellt kolumnnamn enligt faktiska schemat (`vat_type.vat_code` och `vat_rate`). Kontrollera också att rabatter och totalsummor beräknas med samma logik som för fakturor (inklusive avrundning till två decimaler för att undvika avrundningsfel).  
- **Kodstruktur:** Liksom för fakturor är route-funktionen lång. Överväg att flytta erbjudande-logiken till en `OfferController` och en separat service för konvertering till faktura. Detta skulle minska duplicerad kod (t.ex. delar av `computeOfferTotals` liknar `computeInvoiceTotals`) och underlätta underhåll.

salesCreditNotesRoutes.php:  
- **Organisationsscope:** Lägg till organisationfiltrering för **kundkreditnotor**. Endpoints under `/sales/creditnotes` saknar koppling till organizationId, vilket i en multi-tenant-miljö innebär att alla kreditnotor returneras/uppläggs globalt. Lösningen är att kräva `{organizationId}/sales/creditnotes` i URL:en och filtrera på `organization_id` (efter att kolumnen lagts till i `credit_note`-tabellen).  
- **Skapa & uppdatera rader:** Nu hanteras endast kreditnotans huvud – det finns ingen logik för `credit_note_lines`. När en kreditnota skapas via detta API bör även dess rader sparas. Implementera liknande logik som för fakturor: ta emot en lista av rader, beräkna belopp (exkl. och inkl. moms) per rad och inserta dem i `credit_note_lines`-tabellen. Vid PUT bör befintliga rader tas bort/uppdateras. Utan detta blir kreditnotans totalsummor inkonsekventa eller alltid 0.  
- **Numrering:** Inför automatisk numrering av kreditnotor om nummer inte tillhandahålls. I nuläget kan `number` sättas `null`, vilket inte bör ske – systemet ska hitta nästa lediga kreditnotanummer (per org) liknande fakturalogiken.  
- **Bokföring av kreditnota:** Bygg en endpoint för att **bokföra** en kreditnota (t.ex. `POST /sales/creditnotes/{guid}/book`). Den ska likna fakturabokning: kontrollera att kreditnotan är i Draft, markera den som Booked och generera verifikationsposter. Bokföringen bör skapa **huvudbokstransaktioner** som är spegelvända mot en fakturas: t.ex. debitera intäktskonton och moms, kreditera kundfordringar (d.v.s. återför försäljningen). Kontrollera att dessa entries balanserar (summa = 0).  
- **Fält som ej nyttjas:** Flera fält i `credit_note` (t.ex. `fik_code`, `deposit_account_number`, `mail_out_status`) fylls aldrig via denna route. Bestäm om de ska sättas när kreditnotan skapas (t.ex. om `deposit_account_number` bör kopplas till kundens standardbetalningskonto) eller om de är överflödiga – ta i så fall bort dem för att förenkla modellen.

purchaseCreditNotesRoutes.php:  
- **Spegling av leverantörskreditnota:** Säkerställ att hanteringen av **inköpskreditnotor** (leverantörskreditnotor) är komplett. För närvarande kan man skapa en `purchase_credit_note` med rader, men vid bokföring (`/book`) markeras enbart status som Booked utan att någon dubbelbokföring sker. Utöka bokföringssteget: generera huvudboksposter i `entries` som speglar verifikationen. T.ex. om en leverantörskreditnota avser en återbetalning ska den vid bokföring kreditera kostnadskontot och debitera leverantörsskulder (motsatt en leverantörsfaktura).  
- **Datakonsistens:** Kontrollera att insert av rader (`purchase_credit_note_line`) beräknar alla fält korrekt. Just nu tas värden för `base_amount_value`, `total_amount` m.fl. direkt från klienten. Överväg att räkna om dessa på serversidan eller åtminstone validera dem mot ett förväntat samband (t.ex. att `total_amount` = `base_amount_value * quantity`). Detta för att undvika felaktiga summor i databasen.  
- **API-överensstämmelse:** Mappa fält mot swagger-specen: t.ex. använder Dinero API fält som `creditNoteFor` (koppling till ursprungsverifikation) – koden sätter `credit_note_for` men verifiera att det sparas korrekt och att statusövergångar följer förväntningarna (ex. om en leverantörsfaktura är kopplad via `credit_note_for` bör systemet kanske markera den som krediterad).  
- **Behörighet & åtkomst:** Endast admin/redovisningspersonal bör få skapa/bokföra leverantörskreditnotor. Säkerställ att **auth-middleware** appliceras här (om det inte redan sker globalt) så att inte obehöriga kan manipulera verifikationer direkt.  
- **Generellt:** Överväg att slå ihop hanteringen av manuella verifikationer (purchase_credit_note, manual_voucher etc.) under en enhetlig modul. Många fält (t.ex. `booked_by_type`, `timestamp`) antyder generell verifikationshantering. Konsolidering skulle minska redundans och säkerställa att samma kontroll (balans, låst period, m.m.) tillämpas på all bokföring.

ReportController.php:  
- **Momsrapport-data:** Nu förlitar sig rapporten på en tabell/view `ledger_vat` som inte existerar i databasschemat. Lösningen är att **skapa en vy eller tabell** som summerar momstransaktioner per period. Alternativt, ändra logiken att beräkna utgående/ingående moms direkt från `entries` eller `invoice_lines`. Implementera insertering i `ledger_vat` varje gång en verifikation bokförs, eller uppdatera rapportkoden att göra JOINs mot entries baserat på `vat_code` och `vat_type` (t.ex. summéra alla entry-belopp där vat_code indikerar utgående moms).  
- **EU-momshantering:** Rapporten beräknar reverse charge EU-moms (`reverse_output`) och EU-försäljning exkl. moms, men dessa fält byggs på antaganden. Säkerställ att systemet faktiskt sätter `movement = 'eu_goods'/'eu_services'` och `direction` på transactions, annars kommer dessa summor alltid vara 0. Om sådana fält inte förs, uppdatera rapporten att utgå från momskoder (t.ex. anta att momskod “I25” innebär ingående moms, “U25” utgående, “EU…” särskild hantering).  
- **Precision:** Resultatet avrundas till 2 decimaler, vilket är bra. Kontrollera dock att summeringarna (särskilt net_vat_payable) tar hänsyn till både utgående och ingående moms korrekt. Om t.ex. en period ger negativ nettomoms (fordran), kanske det ska visas som negativt belopp eller separat fält. Justera presentationen enligt danska regler för momsrapportering.  
- **Prestanda:** För stora datamängder kan flera SUM-frågor bli tunga. Överväg att låta SQL summera allt i en fråga (SUM CASE… för varje kategori) för färre databasanrop. Detta förbättrar prestanda vid många transaktioner.

SAFTController.php / saftExportRoutes.php:  
- **Dubblettfunktionalitet:** Det finns två implementationer för SAF-T-export (en i SAFTController, en i saftExportRoutes). Konsolidera dessa för att undvika mismatch. Troligen är `saftExportRoutes.php` mer komplett – överväg att ta bort SAFTController och använda route-varianten fullt ut, eller anropa SAFTController från rutten.  
- **Datakonsistens i export:** Koden i `saftExportRoutes` filtrerar konton med `isActive = 1`, men databasen har istället fältet `isHidden`. Byt till `isHidden = 0` eller introducera ett nytt `isActive`-fält i `account`-tabellen och sätt det korrekt. Inkludera även alla nödvändiga masterdata: just nu hämtas kunder och leverantörer från `contacts` baserat på flaggor `is_debitor/is_creditor`. Säkerställ att dessa flaggor sätts rätt (t.ex. vid import eller kontaktregistrering) så att alla relevanta kontakter kommer med i exporten.  
- **Ledger entries i XML:** Den genererade XML:en innehåller `GeneralLedgerEntries`. Se till att alla transaktioner för perioden kommer med. Koden hämtar entries per org och datumspann, men sorterar dem endast – överväg att gruppera i Journaler (SAF-T kräver ofta JournalID/Description per bunt). Implementera t.ex. att alla fakturaverifikat ligger i en Journal “SalesInvoices”, alla manuella i “ManualVouchers” etc., om det efterfrågas av SKAT.  
- **XML-schema och validering:** I slutet valideras XML mot `SAFT_DK.xsd` (i SAFTController). Inkludera denna validering i den nya koden också för att säkerställa att genererat SAF-T följer schemat. Fixa eventuella avvikelser, t.ex. CompanyID bör vara CVR-nummer (nu sätts det till organizationId), AuditFileDateCreated bör sättas om det krävs, och `AccountID` bör motsvara kontonummer. Justera exporten enligt XSD så att den går igenom validering utan fel.

SAFTImportRoutes.php:  
- **Organisationskoppling:** Importlogiken lägger in konton och transaktioner utan att sätta `organization_id` på vissa ställen. T.ex. `SELECT accountNumber FROM account WHERE accountNumber = :accountNumber` – här bör man inkludera `AND organization_id = :orgId` för att inte blanda kontoplaner mellan organisationer. Liknande vid insert: sätt det importerade kontots `organization_id = {organizationId}` istället för att låta det bli globalt.  
- **Dubbelimport och unika nycklar:** Just nu importeras t.ex. ett konto om det inte finns det kontonumret sedan tidigare. Lägg till primärnyckel eller unik index på (organization_id, accountNumber) och fånga konflikter – annars kan samma konto råka importeras dubbelt om importfilen innehåller dubbletter eller om import körs två gånger. Detsamma gäller kontakter (`contact_guid` kan kollidera) – kanske använd kontaktens VAT-nummer eller namn som nyckel för att undvika dubletter, eller generera nya GUID:ar om krock uppstår.  
- **Momskodsmappning:** Heuristiken att mappa kontonummer 3000–3999 till U25 och övriga till I25 är förenklad. Överväg att förbättra detta: Om SAF-T-filen innehåller `TaxCode`/`TaxType` för kontot, mappa dessa till befintliga momskoder i systemet (t.ex. “StandardMoms25” -> U25). Annars låt admin justera i efterhand. Dokumentera för användaren att vissa konton kan behöva manuell justering av moms-kod efter import.  
- **Transaktionsimport:** Importen skapar sannolikt **entries** baserat på `<Journal>`-element. Kontrollera att fält som `voucher_type`, `entry_type` etc. sätts rätt. T.ex. SAF-T “Type” kan vara “Normal” eller “OpeningBalance” – mappa “OpeningBalance” till entry_type “Primo” osv. Om vissa obligatoriska fält i vår DB saknas i filen (t.ex. contact_guid på entries), fundera på hur hantera dem (kanske lämna tomt eller försöka matcha mot importerade kontakter via namn).  
- **Felhantering:** Nu rullas transaktionen tillbaka vid *första* fel. För bättre användarupplevelse, samla gärna alla fel och warnings. Koden bygger en lista `$warnings` – se till att inkludera även oväntade fel (t.ex. om en insert misslyckas p.g.a. constraint) som varningar där det går, istället för att abortera hela importen. Använd loggern för detaljer men returnera tydlig info om vilka poster som hoppades över.  
- **Prestanda:** Vid större SAF-T-filer (många konton/transaktioner) kan importen bli tung. Överväg att batcha inserts (använd `INSERT ... VALUES (...),(...)` för konton och entries istället för att loopa över hundratals `->execute`). Använd transaktionen som nu finns, men optimera inläsningen för att klara större datamängder utan timeout.

